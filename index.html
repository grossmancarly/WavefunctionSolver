<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Wavefunction Solver</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjs/lib/browser/math.js"></script>
</head>
<body>
    <h1>Quantum Wavefunction Solver</h1>
    
    <label for="potential">Enter your potential function V(x):</label>
    <input type="text" id="potentialInput" value="0.5 * x ** 2">
    <button onclick="computeSolution()">Compute Solution</button>
    
    <br><br>
    <canvas id="plot" width="800" height="600"></canvas>
    
    <script>
        // Define the function to compute the Schrödinger equation
        function solveSchrodinger(V_func, x_min=-5, x_max=5, N=1000, mass=1.0, hbar=1.0, num_states=5) {
            // Spatial grid
            const x = [];
            const dx = (x_max - x_min) / (N - 1);
            for (let i = 0; i < N; i++) {
                x.push(x_min + i * dx);
            }
            
            // Potential V(x)
            const V = x.map(V_func);
            
            // Kinetic energy matrix (tridiagonal)
            const factor = Math.pow(hbar, 2) / (2 * mass * Math.pow(dx, 2));
            const diagonal = V.map((v, i) => 2 * factor + v);
            const off_diagonal = new Array(N - 1).fill(-factor);
            
            // Eigenvalue problem: Using the tridiagonal matrix algorithm
            let energies = [];
            let wavefuncs = [];
            
            // Create the Hamiltonian matrix (diagonal and off-diagonal)
            const H = [];
            for (let i = 0; i < N; i++) {
                H.push(new Array(N).fill(0));
                H[i][i] = diagonal[i];
                if (i < N - 1) {
                    H[i][i + 1] = off_diagonal[i];
                    H[i + 1][i] = off_diagonal[i];
                }
            }

            // Solve the eigenvalue problem: compute eigenvalues (energies) and eigenvectors (wavefunctions)
            const eig = numeric.eig(H); // Using numeric.js library for eigenvalue solver
            energies = eig.lambda.slice(0, num_states);
            wavefuncs = eig.E.slice(0, num_states);

            // Normalize the wavefunctions
            wavefuncs.forEach(psi => {
                const norm = Math.sqrt(x.reduce((sum, xi, i) => sum + Math.pow(psi[i], 2) * (x[1] - x[0]), 0));
                psi.forEach((val, i) => psi[i] = val / norm);
            });

            return { x, V, energies, wavefuncs };
        }

        // Function to evaluate the custom potential input from the user
        function parsePotential(input) {
            return function(x) {
                try {
                    return eval(input.replace(/x/g, `(${x})`));
                } catch (e) {
                    alert("Error in potential function! Please check the syntax.");
                    return 0; // Return a default value if there's an error
                }
            };
        }

        // Compute the solution and plot
        function computeSolution() {
            const potentialInput = document.getElementById("potentialInput").value;
            const V_func = parsePotential(potentialInput);

            // Solve Schrödinger equation
            const { x, V, energies, wavefuncs } = solveSchrodinger(V_func, -5, 5, 1000, 1.0, 1.0, 5);

            // Plot the results on the canvas
            const canvas = document.getElementById("plot");
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the potential
            ctx.beginPath();
            ctx.moveTo(x[0], V[0] * 100); // Scale for visibility
            for (let i = 1; i < x.length; i++) {
                ctx.lineTo(x[i], V[i] * 100);
            }
            ctx.strokeStyle = 'black';
            ctx.stroke();
            
            // Draw wavefunctions
            wavefuncs.forEach((psi, index) => {
                ctx.beginPath();
                ctx.moveTo(x[0], psi[0] * 100 + energies[index] * 50); // Scale for visibility
                for (let i = 1; i < x.length; i++) {
                    ctx.lineTo(x[i], psi[i] * 100 + energies[index] * 50);
                }
                ctx.strokeStyle = index % 2 === 0 ? 'blue' : 'red';
                ctx.stroke();
            });
        }

        // Initial computation
        window.onload = computeSolution;
    </script>
</body>
</html>
